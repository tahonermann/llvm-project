// RUN: %clang_cc1 -fsycl-is-host -emit-llvm -triple x86_64 %s -o - | FileCheck %s

// Test IR generated by __builtin_sycl_kernel_name(). This builtin accepts a SYCL
// kernel name type and returns it's mangled name.

class kernel_name_1;
class kernel_name_2;
class single_purpose_kernel_name;

template<typename KN>
struct kernel_id_t {
  using type = KN;
};

template <typename name, typename Func>
__attribute__((sycl_kernel_entry_point(name))) void kernel_single_task(const Func kernelFunc) {
  kernelFunc();
}

// Overloading kernel_single_task
template <typename name, typename Func>
__attribute__((sycl_kernel_entry_point(name))) void kernel_single_task(const Func kernelFunc, int a) {
  kernelFunc();
}

struct SYCLKernel {
  int m;
  public:
  void operator()() const {}
};

__attribute__((sycl_kernel_entry_point(single_purpose_kernel_name)))
void single_purpose_kernel_task(SYCLKernel kernelFunc, int a, int b) {
  kernelFunc();
}


void test() {
  SYCLKernel Obj;
  kernel_single_task<kernel_name_1>(Obj);
  kernel_single_task<kernel_name_2>(Obj, 1);
  single_purpose_kernel_task(Obj, 1, 2);
  int test1 = __builtin_sycl_kernel_param_count(kernel_id_t<kernel_name_1>()); // Returns 1 as corresponding entry point function has 1 argument
  int test2 = __builtin_sycl_kernel_param_count(kernel_id_t<kernel_name_2>()); // Returns 2 as corresponding entry point function has 2 arguments
  int test3 = __builtin_sycl_kernel_param_count(kernel_id_t<single_purpose_kernel_name>()); // Returns 3 as corresponding entry point function has 3 arguments
}

// CHECK: define dso_local void @_Z4testv()
// CHECK: %test1 = alloca i32, align 4 
// CHECK: %test2 = alloca i32, align 4 
// CHECK: %test3 = alloca i32, align 4 
// CHECK: store i32 1, ptr %test1, align 4
// CHECK: store i32 2, ptr %test2, align 4
// CHECK: store i32 3, ptr %test3, align 4 

